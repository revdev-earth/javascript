# Call Stack y Execution Context

## Call Stack

Un **stack**, es decir una pila, sigue la regla **LIFO** = Last In, First Out (Último en entrar, primero en salir).

```javascript
// Contexto global, es donde viven las variables globales.

function primera() {
  console.log("Ejecutando primera()")
  segunda() // Llama a segunda
  console.log("Terminando primera()")
}

function segunda() {
  console.log("Ejecutando segunda()")
  tercera() // Llama a tercera
  console.log("Terminando segunda()")
}

function tercera() {
  console.log("Ejecutando tercera()")
  // No llama a nadie más
}

primera() // Inicia todo
```

### Orden de ejecución:

```
1. Entra primera()     ← Stack: [global, primera]
2. Entra segunda()     ← Stack: [global, primera, segunda]
3. Entra tercera()     ← Stack: [global, primera, segunda, tercera]
4. Sale tercera()      ← Stack: [global, primera, segunda]
5. Sale segunda()      ← Stack: [global, primera]
6. Sale primera()      ← Stack: [global]
```

### Visualización paso a paso:

**Paso 1: Llamamos primera()**

```
┌─────────────┐
│  primera()  │
├─────────────┤
│  global()   │
└─────────────┘
```

**Paso 2: primera() llama a segunda()**

```
┌─────────────┐
│  segunda()  │
├─────────────┤
│  primera()  │
├─────────────┤
│  global()   │
└─────────────┘
```

**Paso 3: segunda() llama a tercera()**

```
┌─────────────┐
│  tercera()  │ ← Se ejecuta ESTA primero
├─────────────┤
│  segunda()  │
├─────────────┤
│  primera()  │
├─────────────┤
│  global()   │
└─────────────┘
```

**Paso 4: tercera() termina, sale del stack**

```
┌─────────────┐
│  segunda()  │ ← Ahora se ejecuta segunda()
├─────────────┤
│  primera()  │
├─────────────┤
│  global()   │
└─────────────┘
```

**Paso 5: segunda() termina, sale del stack**

```
┌─────────────┐
│  primera()  │ ← Ahora continúa primera()
├─────────────┤
│  global()   │
└─────────────┘
```

**Paso 6: primera() termina, sale del stack**

```
┌─────────────┐
│  global()   │ ← Solo queda el contexto global
└─────────────┘
```

## Contextos

### Contexto Global

El **contexto global** es el primer bloque de código de JavaScript.

```javascript
var abuela = "Anita"
const flor = "Rosa"
let edad = 25

function saludar() {
  // ...
}
```

Todo lo que se define sin que entre en una función, clase u objeto es global.

## Stack = Pila de Contextos

Los stacks en JavaScript son un contexto de ejecución.
Pueden tener sus propias variables en el contexto.
También pueden acceder a las variables de contextos superiores.
Además tienen a su disposición un this.

```javascript
// contexto global
// En navegador = `window`, en Node.js = `global`
console.log(this)
const global = "soy global"

function externa() {
  //contexto funcion
  const externa = "soy externa"

  if (true) {
    // contexto bloque, Solo vive en este bloque
    let bloqueVar = "bloque"
    const otra = "también bloque"
  }
  // console.log(bloqueVar); // ❌ Error - no existe aquí

  function interna() {
    const interna = "soy interna"

    // esto se le conoce como Scope Chain
    // ESTE contexto puede ver:
    console.log(interna) // ✅ Su propio contexto
    console.log(externa) // ✅ Contexto padre
    console.log(global) // ✅ Contexto global
  }

  interna()
}
```

## Binding a this

**Binding** significa "enlazar" o "conectar". **This binding** = ¿A qué objeto se conecta `this`?

El valor de `this` depende de **CÓMO** se llama la función, no de dónde se declara.

```javascript
function funcionNormal() {
  // Default Binding (enlace por defecto)
  console.log(this.nombre) // ← `this` en ESTE contexto = global
}

const persona = {
  nombre: "Pedro",
  metodo: function () {
    // Implicit Binding (enlace implícito)
    console.log(this.nombre) // ← Pedro - `this` en ESTE contexto = persona
  },
}

function presentarse() {
  console.log(`Hola, soy ${this.nombre}`)
}

var usuario = { nombre: "María" }

// Explicit binding
// Forzamos el enlace de this
presentarse.call(usuario) // "Hola, soy María"
presentarse.apply(usuario) // "Hola, soy María"
presentarse.bind(usuario)() // "Hola, soy María"

// New Binding (enlace con new)

function Persona(nombre) {
  this.nombre = nombre // this se enlaza al nuevo objeto creado
}

var usuario = new Persona("Carlos") // this = nuevo objeto
console.log(usuario.nombre) // "Carlos"
```

### Arrow Functions (sin binding propio)

```javascript
var persona = {
  nombre: "Pedro",
  metodoNormal: function () {
    console.log(this.nombre) // this = persona

    var arrow = () => {
      console.log(this.nombre) // this = mismo que el padre (persona)
    }

    arrow()
  },
}

persona.metodoNormal()
// "Pedro"
// "Pedro" (arrow toma el this del contexto padre)
```

### Ejemplo de binding perdido:

```javascript
var obj = {
  nombre: "Mi objeto",
  metodo: function () {
    console.log(this.nombre)
  },
}

// Binding implícito
obj.metodo() // "Mi objeto" - this = obj

// Binding perdido
var funcionSuelta = obj.metodo
funcionSuelta() // undefined - this = window (perdió el contexto)

// Binding explícito para recuperar contexto
funcionSuelta.call(obj) // "Mi objeto" - this = obj (forzado)
```

### Resumen de This Binding:

- **Default:** this = global (window/undefined)
- **Implicit:** this = objeto que llama al método
- **Explicit:** this = objeto especificado con call/apply/bind
- **New:** this = nuevo objeto creado
- **Arrow:** this = contexto padre (no tiene su propio this)

## Stack Overflow

Cuando hay demasiadas funciones en el stack:

```javascript
function recursionInfinita() {
  recursionInfinita() // ¡Esto llena el stack infinitamente!
}
// Error: "Maximum call stack size exceeded"
```

### Visualización del Stack Overflow:

```
LÍMITE DEL STACK ⚠️
┌─────────────────────────────┐
│ recursionInfinita() #12000  │ ← ¡BOOM! Stack lleno
├─────────────────────────────┤
│          ...                │
├─────────────────────────────┤
│ recursionInfinita() #1      │
├─────────────────────────────┤
│ CONTEXTO GLOBAL             │
└─────────────────────────────┘
Error: "Maximum call stack size exceeded"
```

### Límites del Call Stack por navegador/entorno:

| Entorno       | Límite aproximado | Observaciones                   |
| ------------- | ----------------- | ------------------------------- |
| **Chrome V8** | ~12,000 llamadas  | Varía según RAM disponible      |
| **Firefox**   | ~9,000 llamadas   | Puede ser mayor con más memoria |
| **Safari**    | ~10,000 llamadas  | Depende del dispositivo         |
| **Node.js**   | ~15,000 llamadas  | Stack size: 984KB por defecto   |
| **Edge**      | ~11,000 llamadas  | Similar a Chrome                |

**Nota:** Estos límites pueden variar según:

- RAM disponible del sistema
- Tamaño de cada frame del stack
- Configuración del navegador/entorno

### Recursión correcta (con caso base):

```javascript
function factorial(n) {
  if (n <= 1) return 1 // ← Caso base - detiene la recursión
  return n * factorial(n - 1)
}

console.log(factorial(5)) // 120 - No hay problema
```

### Visualización de recursión controlada:

```
┌─────────────────────────────┐
│ factorial(1) return 1       │ ← Caso base alcanzado
├─────────────────────────────┤
│ factorial(2) return 2*1     │
├─────────────────────────────┤
│ factorial(3) return 3*2     │
├─────────────────────────────┤
│ factorial(4) return 4*6     │
├─────────────────────────────┤
│ factorial(5) return 5*24    │
├─────────────────────────────┤
│ CONTEXTO GLOBAL             │
└─────────────────────────────┘
Result: 120 ✅
```

### Cómo evitar Stack Overflow:

```javascript
// ❌ Malo - Recursión infinita
function malo(n) {
  return malo(n - 1) // Sin caso base
}

// ✅ Bueno - Con caso base
function bueno(n) {
  if (n <= 0) return 0 // Caso base
  return n + bueno(n - 1)
}

// ✅ Alternativa - Iterativo (no usa stack)
function iterativo(n) {
  let resultado = 0
  for (let i = 1; i <= n; i++) {
    resultado += i
  }
  return resultado
}
```

## Resumen Clave

- **Stack** = Pila de contextos de ejecución
- **Cada nivel del stack** = Un contexto independiente
- **LIFO** = Las funciones salen en orden inverso al que entraron
- **Contexto Global** = Siempre está en la base del stack
- **Variables locales** = Solo viven en su contexto
- **Scope Chain** = Permite acceder a contextos padres
- **This** = Depende de cómo se llama la función
