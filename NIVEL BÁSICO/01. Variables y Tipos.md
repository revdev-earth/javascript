# Variables y Tipos

## 1. Tipo de variables

### const - let - var

```javascript
const PI = 3.14159 // Por defecto - para valores que no van a cambiar
let contador = 0 // Cuando después se quiera cambiar el valor
var apellido = "Pérez" // Primera definicion de javascript, uso global, no recomendada.
```

## 2. Detectando tipos

### typeof - Para saber qué tipo es algo:

```javascript
console.log(typeof "hola") // "string"
console.log(typeof 42) // "number"
console.log(typeof true) // "boolean"
console.log(typeof undefined) // "undefined"
```

### Casos especiales (que confunden):

```javascript
console.log(typeof null) // "object" ← ¡Bug histórico! en JS
console.log(typeof []) // "object" ← Arrays son objetos
console.log(typeof {}) // "object"
```

### instanceof - Para objetos específicos:

```javascript
let lista = []
let persona = {}
let fecha = new Date()

console.log(lista instanceof Array) // true
console.log(lista instanceof Object) // true (todos los arrays son objetos)
console.log(persona instanceof Object) // true
console.log(fecha instanceof Date) // true
console.log(fecha instanceof Object) // true
```

## 3. Primitivos

### Los 7 tipos primitivos:

```javascript
let texto = "Hola mundo" // string (texto)
let numero = 42 // number (número)
let esVerdad = true // boolean (verdadero/falso)
let sinValor = undefined // undefined (sin definir / asignar)
let vacio = null // null (nulo, inexistente o vacío") Viene del latín nullus ("ninguno")
let simbolo = Symbol("id") // symbol (identificador único)
let numeroGrande = 123n // bigint (números muy grandes)
```

### La copia de los primitivos:

```javascript
let a = 5
let b = a
a = 10
console.log(a) // 10
console.log(b) // 5
```

## 4. Objetos

Después de los primitivos tenemos los objetos, podemos identificar un tipo de variable con `typeof`.

Tenemos varios tipos de objetos: objeto literal - array - Date

```javascript
// Objeto literal
let persona = { nombre: "Ana", edad: 25 }
console.log(typeof persona) // 'object'

// Array
let lista = [1, 2, 3]
console.log(typeof lista) // 'object'

// Date
let fecha = new Date()
console.log(typeof fecha) // 'object'
```

### Apuntando objetos:

```javascript
// Los objetos comparten la misma ubicación en memoria
let persona1 = { nombre: "Ana" }
let persona2 = persona1 // persona2 apunta al MISMO objeto
persona1.nombre = "Luis"
console.log(persona2.nombre) // "Luis" - ¡cambió también!
```

### Para hacer una copia real de un objeto:

```javascript
let persona1 = { nombre: "Ana" }
let persona2 = { ...persona1 } // Copia real (spread operator)
persona1.nombre = "Luis"
console.log(persona2.nombre) // "Ana" - no cambió
```

## 5. undefined vs null

```javascript
let x // undefined (declarada pero sin valor)
let y = null // null (intencionalmente vacío)

console.log(x) // undefined - "No se asignó nada"
console.log(y) // null - "Está vacío a propósito"
```

### En la práctica:

```javascript
// JavaScript asigna undefined automáticamente
let nombre
console.log(nombre) // undefined

// Tú asignas null cuando quieres "vacío"
let usuario = null // "No hay usuario logueado"

// Comparando
console.log(undefined == null) // true (son "equivalentes")
console.log(undefined === null) // false (son tipos diferentes)
```

## 6. Coerción

Convierte automáticamente un tipo a otro para hacer que algo funcione.

### Casos automáticos:

```javascript
// Con números y texto

5 + "3" // "53" - convierte 5 a texto
"10" - 2 // 8 - convierte "10" a número
"5" * "2" // 10 - convierte ambos a números

// El operador + prefiere texto (concatenación)

5 + "años" // "5años"

// Los otros operadores (-, *, /) solo funcionan con números

"10" - 2 // 8
"10" * 2 // 20
"10" / 2 // 5
```

### Con booleanos:

```javascript
console.log(true + 1) // 2 (true = 1)
console.log(false + 1) // 1 (false = 0)
```

### Conversión manual (cuando tú decides):

```javascript
// Convertir a número
Number("123") // 123
parseInt("42px") // 42 (ignora el texto)
parseFloat("3.14") // 3.14

// Convertir a texto
String(456) // "456"

// Convertir a boolean
Boolean("hola") // true
Boolean("") // false
Boolean(0) // false
```

## 7. Comparaciones

### Usa siempre ===

```javascript
// === compara sin cambiar tipos
5 === 5 // true
5 === "5" // false (número vs texto)

// == puede cambiar tipos (confuso)
5 == "5" // true (convierte "5" a número)
```

### Valores que se consideran "falsy" (falsos):

```javascript
if (!false) console.log("false es falsy") // ✓
if (!0) console.log("0 es falsy") // ✓
if (!"") console.log("string vacío es falsy") // ✓
if (!null) console.log("null es falsy") // ✓
if (!undefined) console.log("undefined es falsy") // ✓
if (!NaN) console.log("NaN es falsy") // ✓
```

### Todo lo demás es "truthy" (verdadero):

```javascript
if ("false") console.log("String 'false' es truthy") // ✓
if ([]) console.log("Array vacío es truthy") // ✓
if ({}) console.log("Objeto vacío es truthy") // ✓
```

### NaN - Not a Number:

```javascript
console.log("hola" - 1) // NaN (Not a Number)
console.log(NaN === NaN) // false ← ¡NaN no es igual a sí mismo!

// Para verificar si algo es NaN
console.log(Number.isNaN(NaN)) // true
console.log(Number.isNaN("hola")) // false
```

## 8. Hoisting - Las variables "suben"

Las variables declaradas con **var** son 'hoisted', es decir, movidas hacia arriba y se inicializan automáticamente con `undefined`.

```javascript
console.log(x) // undefined (variable hoisted)
var x = 5
```

JavaScript lo interpreta así internamente:

```javascript
var x // hoisting
console.log(x) // undefined
x = 5
```

Con **let** y **const** hay hoisting, pero no se inicializan. Permanecen en la Temporal Dead Zone (TDZ) hasta la línea donde se declaran, y por eso dan ReferenceError si se usan antes.

```javascript
console.log(y) // ReferenceError
let y = 10

console.log(z) // ReferenceError
const z = 20
```
