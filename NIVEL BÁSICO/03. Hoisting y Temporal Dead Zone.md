# 03. Hoisting y Temporal Dead Zone

## 1. Conceptos Básicos

### var hoisting:

```javascript
console.log(miVar) // undefined (no error)
var miVar = "Hola"

// JavaScript internamente hace esto:
// var miVar;
// console.log(miVar); // undefined
// miVar = "Hola";
```

### function hoisting:

```javascript
saludar() // "Hola" - funciona antes de declararla

function saludar() {
  console.log("Hola")
}

// Pero las expresiones de función NO:
// despedir(); // TypeError
var despedir = function () {
  console.log("Adiós")
}
```

### let/const TDZ (Temporal Dead Zone):

```javascript
console.log(x) // ReferenceError: Cannot access before initialization
let x = 5

console.log(y) // ReferenceError: Cannot access before initialization
const y = 10
```

## 2. Hoisting en otros escenarios

### Hoisting en diferentes scopes:

```javascript
// Global + Function scope
var global = "global"

function ejemplo() {
  console.log(global) // undefined (hoisted var global shadows global)
  console.log(local) // undefined (hoisted)

  var global = "local global"
  var local = "local"
}

ejemplo()
```

### Function vs Expression hoisting:

```javascript
// Declaración - totalmente hoisted
console.log(declaracion()) // "Funciona!"

function declaracion() {
  return "Funciona!"
}

// Expresión - solo la variable es hoisted
console.log(expresion) // undefined
console.log(expresion()) // TypeError: expresion is not a function

var expresion = function () {
  return "No funciona antes"
}
```

## 3. Temporal Dead Zone

### TDZ en diferentes contextos:

```javascript
// Block scope TDZ
{
  console.log(x) // ReferenceError - TDZ
  let x = 1

  console.log(y) // ReferenceError - TDZ
  const y = 2
}

// Function parameter TDZ
function ejemplo(a = b, b = 1) {
  // ReferenceError
  // b está en TDZ cuando se evalúa a
}

// Class TDZ
console.log(MiClase) // ReferenceError
class MiClase {}
```

### typeof con TDZ:

```javascript
// Con var (no TDZ)
console.log(typeof miVar) // "undefined"
var miVar = 5

// Con let/const (TDZ)
console.log(typeof miLet) // ReferenceError
let miLet = 10
```

## 4. Situaciones Comunes y Debug

### Situación común con var en loops:

```javascript
// Situación típica con var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100) // 3, 3, 3
}

// Lo que realmente pasa:

// 1. var i se declara UNA SOLA VEZ para toda la función
// 2. El loop corre 3 veces MUY RÁPIDO (milisegundos):
//    - i = 0, crea setTimeout #1
//    - i = 1, crea setTimeout #2
//    - i = 2, crea setTimeout #3
//    - i = 3, condición i < 3 es false, loop termina
// 3. Después de 100ms, los setTimeout se ejecutan y todos ven i = 3

// Es como si fuera esto:
var i // UNA sola variable para todo
for (i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100) // Todos apuntan a la MISMA i
}
// Aquí i ya vale 3

// Solución moderna con let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100) // 0, 1, 2
}

// let crea una NUEVA variable i en cada iteración:
// Iteración 0: let i = 0, setTimeout ve su propia i = 0
// Iteración 1: let i = 1, setTimeout ve su propia i = 1
// Iteración 2: let i = 2, setTimeout ve su propia i = 2

// Otras formas de lograr lo mismo con var:

// 1. IIFE (Immediately Invoked Function Expression)
for (var i = 0; i < 3; i++) {
  ;(function (j) {
    setTimeout(() => console.log(j), 100) // 0, 1, 2
  })(i) // Pasamos i como parámetro j
}

// 2. bind()
for (var i = 0; i < 3; i++) {
  setTimeout(
    function (j) {
      console.log(j)
    }.bind(null, i),
    100
  ) // 0, 1, 2
}

// 3. Parámetro extra en setTimeout
for (var i = 0; i < 3; i++) {
  setTimeout(
    function (j) {
      console.log(j)
    },
    100,
    i
  ) // El tercer parámetro se pasa a la función
}

// 4. Crear una función separada
function crearTimeout(valor) {
  setTimeout(() => console.log(valor), 100)
}

for (var i = 0; i < 3; i++) {
  crearTimeout(i) // 0, 1, 2
}

// 5. forEach (si tienes un array)
;[0, 1, 2].forEach(function (i) {
  setTimeout(() => console.log(i), 100) // 0, 1, 2
})
```

### Debug de hoisting:

```javascript
function debugHoisting() {
  console.log("1. miVar:", typeof miVar) // undefined
  console.log("2. miFuncion:", typeof miFuncion) // function

  try {
    console.log("3. miLet:", miLet) // ReferenceError
  } catch (e) {
    console.log("3. Error TDZ:", e.name)
  }

  var miVar = "valor"
  let miLet = "valor let"

  function miFuncion() {
    return "hoisted"
  }
}
```

## 5. Best Practices

### Initialization patterns:

```javascript
// Patrón: Declarar e inicializar juntos
const config = {
  api: process.env.API_URL || "http://localhost",
  timeout: 5000,
}

// Patrón: Destructuring con defaults
const { nombre = "Anónimo", edad = 0 } = usuario || {}

// Patrón: Conditional initialization
let manager
if (isAdmin) {
  manager = new AdminManager()
} else {
  manager = new UserManager()
}
```

### Evitar situaciones confusas:

```javascript
// ❌ Comportamiento impredecible
function confuso() {
  if (condition) {
    function helper() {
      return "version 1"
    }
  } else {
    function helper() {
      return "version 2"
    }
  }
  return helper() // Comportamiento impredecible
}

// ✅ Más claro
function claro() {
  let helper
  if (condition) {
    helper = function () {
      return "version 1"
    }
  } else {
    helper = function () {
      return "version 2"
    }
  }
  return helper()
}
```

## 6. Performance Implications

### Hoisting y memoria:

```javascript
// Todas las functions se crean al inicio
function ejemplo() {
  // Esta función se crea aunque nunca se use
  function helper1() {
    /* código pesado */
  }
  function helper2() {
    /* código pesado */
  }

  if (simpleCondition) {
    return "simple"
  }

  // Helpers nunca se usan pero ya están en memoria
}

// Mejor: Lazy initialization
function mejorEjemplo() {
  if (simpleCondition) {
    return "simple"
  }

  // Solo crear cuando sea necesario
  const helper1 = function () {
    /* código pesado */
  }
  const helper2 = function () {
    /* código pesado */
  }

  // usar helpers...
}
```
