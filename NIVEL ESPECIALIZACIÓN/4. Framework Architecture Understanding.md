# 4. Framework Architecture Understanding

Conocer la arquitectura interna de frameworks como **React**, **Vue** y **Angular** te permite optimizar rendimiento, depurar problemas complejos y crear soluciones m치s avanzadas.

## 1. React Internals

React utiliza un **Virtual DOM** y un algoritmo llamado **Reconciliation** para minimizar actualizaciones reales en el DOM.

**Ciclo simplificado:**

1. Se crea una representaci칩n virtual del DOM.
2. Cuando cambia el estado, React genera un nuevo Virtual DOM.
3. Se compara el nuevo con el anterior (**diffing**).
4. Solo los nodos cambiados se actualizan en el DOM real.

**Ejemplo de re-render controlado:**

```jsx
import { memo } from "react";

const Boton = memo(({ onClick }) => {
  console.log("Renderizado");
  return <button onClick={onClick}>Click</button>;
});
```

_(memo evita renders innecesarios si las props no cambian)_

## 2. Vue Reactivity

Vue usa **proxies** para observar cambios en datos y actualizar la UI de forma reactiva.

**Ejemplo con `reactive`:**

```javascript
import { reactive, watch } from "vue";

const estado = reactive({ contador: 0 });

watch(
  () => estado.contador,
  (nuevo) => {
    console.log("Nuevo valor:", nuevo);
  }
);

estado.contador++; // Dispara el watch
```

_(Vue intercepta el acceso y asignaci칩n a propiedades para detectar cambios)_

## 3. Angular Zones

Angular utiliza **NgZone** para detectar autom치ticamente cambios y actualizar la vista.

**Ejemplo forzando detecci칩n de cambios:**

```typescript
import { Component, NgZone } from "@angular/core";

@Component({
  selector: "app-root",
  template: `{{ contador }}`,
})
export class AppComponent {
  contador = 0;
  constructor(zone: NgZone) {
    zone.runOutsideAngular(() => {
      setInterval(() => {
        zone.run(() => this.contador++);
      }, 1000);
    });
  }
}
```

_(runOutsideAngular evita renders innecesarios y mejora rendimiento)_

## 4. Virtual DOM

Es una copia en memoria del DOM real que permite:

- Actualizaciones r치pidas.
- Batch de cambios.
- Re-render selectivo.

**Beneficio:** manipular objetos JS es m치s r치pido que manipular nodos reales del navegador.

## 5. Component Lifecycle

Cada framework tiene hooks para diferentes fases del ciclo de vida del componente.

**React (Functional + Hooks):**

```javascript
useEffect(() => {
  console.log("Montado");
  return () => console.log("Desmontado");
}, []);
```

**Vue:**

```javascript
onMounted(() => console.log("Montado"));
onBeforeUnmount(() => console.log("Desmontado"));
```

**Angular:**

```typescript
ngOnInit() { console.log("Iniciado"); }
ngOnDestroy() { console.log("Destruido"); }
```

## 6. State Management

La gesti칩n de estado puede ser local (useState, reactive) o global (Redux, Pinia, NgRx).

**Ejemplo con Redux:**

```javascript
const contadorReducer = (state = 0, action) => {
  switch (action.type) {
    case "INCREMENTAR":
      return state + 1;
    default:
      return state;
  }
};
```

## 7. Routing

El enrutamiento maneja la navegaci칩n sin recargar la p치gina.

**React Router:**

```jsx
import { BrowserRouter, Route, Routes } from "react-router-dom";

<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/perfil" element={<Perfil />} />
  </Routes>
</BrowserRouter>;
```

**Vue Router:**

```javascript
const routes = [{ path: "/", component: Home }];
const router = createRouter({ history: createWebHistory(), routes });
```

游눠 **Tip experto:** Entender internamente estos frameworks permite optimizar el uso de hooks, directivas o servicios, y escribir c칩digo m치s predecible y eficiente.
