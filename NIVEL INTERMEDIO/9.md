# 9. State Management Patterns

En JavaScript (y sobre todo en aplicaciones modernas con React, Vue, Angular, etc.), gestionar el estado significa manejar y coordinar los datos que la aplicación necesita para funcionar.

Un manejo de estado correcto es clave para mantener coherencia, predecibilidad y mantenibilidad en el código.

## Local State

El estado local es aquel que solo vive dentro de un componente, función o módulo. Es ideal para datos que no necesitan compartirse.

### Ejemplo en React:

```javascript
function Contador() {
  const [contador, setContador] = React.useState(0)

  return (
    <div>
      <p>Valor: {contador}</p>
      <button onClick={() => setContador(contador + 1)}>Incrementar</button>
    </div>
  )
}
```

### Ventajas:

- Simplicidad.
- Bajo acoplamiento.
- Rápida implementación.

### Desventajas:

- Difícil de compartir entre componentes.

## Shared State

Cuando varios componentes necesitan los mismos datos, debemos levantar el estado (state lifting) o usar un contenedor común.

### Ejemplo con React usando props:

```javascript
function Padre() {
  const [usuario, setUsuario] = React.useState("Nico")

  return (
    <>
      <Hijo1 usuario={usuario} />
      <Hijo2 usuario={usuario} />
    </>
  )
}
```

### Desventajas:

- Props drilling (pasar datos por múltiples niveles).
- Escalabilidad limitada.

## State Machines

Las máquinas de estado permiten modelar el flujo de datos y sus posibles transiciones de forma explícita. Cada estado tiene un conjunto definido de eventos que puede aceptar.

### Ejemplo con XState:

```javascript
import { createMachine } from "xstate"

const semaforo = createMachine({
  id: "semaforo",
  initial: "verde",
  states: {
    verde: { on: { CAMBIAR: "amarillo" } },
    amarillo: { on: { CAMBIAR: "rojo" } },
    rojo: { on: { CAMBIAR: "verde" } },
  },
})
```

### Ventajas:

- Comportamiento predecible.
- Fácil de testear.
- Ideal para flujos complejos.

## Flux Pattern

Arquitectura unidireccional de datos.

### Conceptos clave:

- **Actions** → describen lo que ocurre.
- **Dispatcher** → envía acciones a stores.
- **Store** → mantiene el estado.
- **View** → renderiza la UI según el store.

```javascript
// Ejemplo simplificado
store.dispatch({ type: "INCREMENTAR" })
```

## Observer Pattern

Permite que múltiples objetos observen un mismo estado y reaccionen cuando cambia.

```javascript
class Subject {
  constructor() {
    this.observers = []
  }

  subscribe(fn) {
    this.observers.push(fn)
  }

  notify(data) {
    this.observers.forEach((fn) => fn(data))
  }
}

const estado = new Subject()
estado.subscribe((data) => console.log("Nuevo estado:", data))
estado.notify({ user: "Nico" })
```

## State Synchronization

Mantener varios estados en diferentes partes sincronizados (por ejemplo, en tabs, ventanas o con un backend).

```javascript
// Ejemplo con localStorage
window.addEventListener("storage", (e) => {
  if (e.key === "theme") {
    console.log("Tema sincronizado:", e.newValue)
  }
})
```

## Immutable Updates

En aplicaciones complejas, nunca modificar directamente el estado, sino crear una copia modificada.

```javascript
// Incorrecto
estado.usuario.nombre = "Juan"

// Correcto
const nuevoEstado = {
  ...estado,
  usuario: { ...estado.usuario, nombre: "Juan" },
}
```

### Ventajas:

- Evita efectos colaterales.
- Compatible con time-travel debugging (Redux DevTools).
- Mejora la predictibilidad.

## Redux Patterns

Redux implementa el patrón Flux, pero con reglas estrictas:

- Estado global inmutable.
- Reducers puros.
- Acciones planas.

```javascript
// Reducer
function contadorReducer(state = { valor: 0 }, action) {
  switch (action.type) {
    case "INCREMENTAR":
      return { valor: state.valor + 1 }
    default:
      return state
  }
}
```

## Context API

En React, permite evitar props drilling compartiendo estado de forma global sin librerías externas.

```javascript
const TemaContext = React.createContext()

function App() {
  const [tema, setTema] = React.useState("claro")

  return (
    <TemaContext.Provider value={{ tema, setTema }}>
      <ComponenteHijo />
    </TemaContext.Provider>
  )
}
```

## State Persistence

Guardar el estado para que persista tras recargar la página.

```javascript
const guardarEstado = (clave, valor) => {
  localStorage.setItem(clave, JSON.stringify(valor))
}

const obtenerEstado = (clave) => {
  return JSON.parse(localStorage.getItem(clave))
}
```

## Undo/Redo

Permite navegar hacia atrás y adelante en el historial del estado.

```javascript
class Historial {
  constructor() {
    this.pasado = []
    this.presente = null
    this.futuro = []
  }

  set(estado) {
    if (this.presente) this.pasado.push(this.presente)
    this.presente = estado
  }

  undo() {
    if (this.pasado.length > 0) {
      this.futuro.push(this.presente)
      this.presente = this.pasado.pop()
    }
  }

  redo() {
    if (this.futuro.length > 0) {
      this.pasado.push(this.presente)
      this.presente = this.futuro.pop()
    }
  }
}
```

## Resumen visual de patrones de estado:

- **Local** → Componente pequeño.
- **Shared** → Entre componentes.
- **State Machine** → Flujo definido.
- **Flux / Redux** → Estado global estructurado.
- **Observer** → Reactividad manual.
- **Context API** → Compartir sin props drilling.
- **Persistencia** → Guardar entre sesiones.
- **Undo/Redo** → Historial navegable.
