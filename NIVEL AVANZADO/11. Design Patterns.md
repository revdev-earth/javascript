# 11. Design Patterns

Los patrones de diseÃ±o son soluciones reutilizables a problemas comunes de arquitectura y estructura de cÃ³digo.
Se dividen en tres categorÃ­as principales:

## 1. Creational Patterns (Patrones Creacionales)

Se enfocan en cÃ³mo crear objetos de manera flexible y reutilizable.

### Factory Pattern

Crea objetos sin exponer la lÃ³gica de creaciÃ³n al cliente.

```javascript
class Auto {
  constructor(modelo) {
    this.modelo = modelo;
  }
}

class AutoFactory {
  crearAuto(modelo) {
    return new Auto(modelo);
  }
}

const factory = new AutoFactory();
const auto1 = factory.crearAuto("Tesla");
console.log(auto1.modelo); // Tesla
```

### Singleton Pattern

Garantiza que solo exista una instancia de una clase.

```javascript
class Config {
  constructor() {
    if (Config.instance) return Config.instance;
    this.ajustes = {};
    Config.instance = this;
  }
}

const c1 = new Config();
const c2 = new Config();
console.log(c1 === c2); // true
```

## 2. Structural Patterns (Patrones Estructurales)

Se centran en cÃ³mo organizar clases y objetos para formar estructuras mÃ¡s grandes.

### Module Pattern

Encapsula variables y funciones para evitar contaminaciÃ³n global.

```javascript
const moduloContador = (function () {
  let contador = 0;
  return {
    incrementar: () => ++contador,
    obtener: () => contador,
  };
})();

console.log(moduloContador.incrementar()); // 1
console.log(moduloContador.obtener()); // 1
```

### Decorator Pattern

Agrega funcionalidades sin modificar el cÃ³digo original.

```javascript
function logger(fn) {
  return function (...args) {
    console.log("Llamando a la funciÃ³n con", args);
    return fn(...args);
  };
}

const sumar = (a, b) => a + b;
const sumarConLog = logger(sumar);
console.log(sumarConLog(3, 4)); // Llamando..., 7
```

## 3. Behavioral Patterns (Patrones de Comportamiento)

Se enfocan en cÃ³mo los objetos interactÃºan.

### Observer Pattern

Permite que un objeto (subject) notifique a mÃºltiples observadores cuando cambia su estado.

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  notify(data) {
    this.observers.forEach((o) => o(data));
  }
}

const subject = new Subject();
subject.subscribe((data) => console.log("Observer 1:", data));
subject.subscribe((data) => console.log("Observer 2:", data));

subject.notify("Hola observadores!");
```

## MVC / MVP

MVC (Model-View-Controller)
SeparaciÃ³n de responsabilidades:

- Model â†’ Datos y lÃ³gica.
- View â†’ Interfaz de usuario.
- Controller â†’ Conecta vista y modelo.

Ejemplo simplificado:

```javascript
// Model
class Producto {
  constructor(nombre, precio) {
    this.nombre = nombre;
    this.precio = precio;
  }
}

// View
class ProductoView {
  render(producto) {
    console.log(`Producto: ${producto.nombre}, Precio: ${producto.precio}`);
  }
}

// Controller
class ProductoController {
  constructor(model, view) {
    this.model = model;
    this.view = view;
  }
  mostrarProducto() {
    this.view.render(this.model);
  }
}

const producto = new Producto("Laptop", 2000);
const vista = new ProductoView();
const controlador = new ProductoController(producto, vista);
controlador.mostrarProducto();
```

ðŸ“Œ Resumen por categorÃ­a:

| CategorÃ­a  | Ejemplos comunes            |
| ---------- | --------------------------- |
| Creational | Factory, Singleton, Builder |
| Structural | Module, Decorator, Adapter  |
| Behavioral | Observer, Strategy, Command |
