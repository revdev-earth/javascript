# 12. Application Architecture Patterns

La arquitectura de aplicaci√≥n define la forma en que se organizan los componentes, c√≥mo se comunican y c√≥mo se gestionan responsabilidades y dependencias.

## 1. Layered Architecture (Arquitectura en Capas)

Organiza la aplicaci√≥n en capas jer√°rquicas, cada una con una responsabilidad espec√≠fica.

#### Ejemplo t√≠pico: Presentaci√≥n ‚Üí L√≥gica de Negocio ‚Üí Persistencia.

```javascript
// Capa de Persistencia
class UserRepository {
  getUserById(id) {
    return { id, name: "Nico" }; // simulando BD
  }
}

// Capa de L√≥gica de Negocio
class UserService {
  constructor(repo) {
    this.repo = repo;
  }
  getUserName(id) {
    return this.repo.getUserById(id).name;
  }
}

// Capa de Presentaci√≥n
const repo = new UserRepository();
const service = new UserService(repo);
console.log(service.getUserName(1)); // Nico
```

Ventajas: separaci√≥n clara, f√°cil mantenimiento.
Desventaja: puede volverse r√≠gida para cambios complejos.

## 2. Hexagonal Architecture (Puertos y Adaptadores)

Dise√±ada para aislar el n√∫cleo de negocio de la infraestructura (bases de datos, APIs, UI).

- Core: l√≥gica de negocio pura.
- Ports: interfaces.
- Adapters: implementaciones concretas.

```javascript
// Core (puerto)
class PaymentService {
  constructor(paymentGateway) {
    this.paymentGateway = paymentGateway;
  }
  process(amount) {
    return this.paymentGateway.charge(amount);
  }
}

// Adapter
class StripeAdapter {
  charge(amount) {
    return `Cobrando $${amount} con Stripe`;
  }
}

const service = new PaymentService(new StripeAdapter());
console.log(service.process(100)); // Cobrando $100 con Stripe
```

## 3. Clean Architecture

Similar a la hexagonal, pero con anillos conc√©ntricos donde las dependencias siempre apuntan hacia el n√∫cleo.
Prioriza:

- Independencia de frameworks.
- Independencia de UI.
- Testabilidad.

## 4. CQRS (Command Query Responsibility Segregation)

Separa las operaciones de lectura (queries) de las de escritura (commands).

#### Ejemplo: en vez de tener un solo m√©todo UserService, tienes:

- CommandService ‚Üí cambiar datos.
- QueryService ‚Üí leer datos.

```javascript
class UserCommandService {
  createUser(data) {
    console.log("Usuario creado", data);
  }
}
class UserQueryService {
  getUser(id) {
    return { id, name: "Ana" };
  }
}
```

## 5. Event Sourcing

En vez de almacenar solo el estado actual, guarda todos los eventos que llevaron a ese estado.

#### Ejemplo:

```javascript
let events = [];
function applyEvent(event) {
  events.push(event);
}

applyEvent({ type: "USER_CREATED", data: { id: 1, name: "Juan" } });
applyEvent({ type: "USER_RENAMED", data: { id: 1, name: "Pedro" } });
console.log(events);
```

Ventaja: historial completo; Desventaja: m√°s complejidad.

## 6. Microservices Patterns

Divide la aplicaci√≥n en servicios independientes que se comunican por API/cola de mensajes.
Patrones comunes:

- API Gateway.
- Saga Pattern (coordinaci√≥n de transacciones).
- Service Registry.

## 7. Domain-Driven Design (DDD)

Centrado en el dominio de negocio y su lenguaje ubicuo.
Elementos:

- Entities (objetos con identidad).
- Value Objects (objetos sin identidad, solo valores).
- Aggregates (agrupaciones coherentes).
- Bounded Contexts (fronteras de significado).

## 8. Dependency Injection (DI)

En vez de que una clase cree sus dependencias, se las pasas desde fuera.

```javascript
class Service {
  constructor(repo) {
    this.repo = repo;
  }
}
const service = new Service(new UserRepository()); // Inyectado
```

## 9. Composition Root

Punto √∫nico donde se construyen e inyectan todas las dependencias de la app.

#### Ejemplo: el archivo main.js en Node.js que inicializa todos los servicios.

## 10. Bounded Contexts

En DDD, significa delimitar claramente qu√© parte del sistema maneja qu√© conceptos.

#### Ejemplo:

Contexto de Facturaci√≥n no necesita saber c√≥mo funciona Inventario.

Se comunican mediante eventos o APIs.

### üìå Resumen visual:

| Patr√≥n | Uso principal |
Layered Architecture Separar capas
Hexagonal Aislar n√∫cleo
Clean Architecture Dependencias hacia el n√∫cleo
CQRS Separar lectura y escritura
Event Sourcing Guardar historial
Microservices Desacoplar en servicios
DDD Modelar dominio
DI Inyectar dependencias
Composition Root Configuraci√≥n inicial
Bounded Contexts Delimitar responsabilidades
