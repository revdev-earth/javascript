# 9. Proxy y Metaprogramming

En JavaScript, un Proxy permite interceptar y redefinir operaciones fundamentales sobre objetos (lectura, escritura, borrado, etc.).
Esto habilita t√©cnicas avanzadas de metaprogramaci√≥n, es decir, c√≥digo que manipula el comportamiento de otro c√≥digo.

## Proxy Handlers

Un Proxy recibe:

- Target ‚Üí El objeto original.
- Handler ‚Üí Un objeto que define traps (m√©todos especiales para interceptar operaciones).

Ejemplo b√°sico:

```javascript
const target = { nombre: "Ana" };

const handler = {
  get(obj, prop) {
    return prop in obj ? obj[prop] : `La propiedad ${prop} no existe`;
  },
};
const proxy = new Proxy(target, handler);
console.log(proxy.nombre); // Ana
console.log(proxy.edad); // La propiedad edad no existe
```

## Reflect API

La API Reflect proporciona m√©todos para realizar operaciones est√°ndar de objetos sin tener que llamar funciones internas directamente.

Ejemplo usando Reflect para delegar comportamiento:

```javascript
const persona = { nombre: "Luis" };

const proxy = new Proxy(persona, {
  set(obj, prop, valor) {
    console.log(`Asignando ${valor} a ${prop}`);
    return Reflect.set(obj, prop, valor); // Llamada est√°ndar
  },
});

proxy.nombre = "Carlos"; // Asignando Carlos a nombre
```

## Property Interception

Con Proxy puedes:

- Controlar acceso (get)
- Validar escritura (set)
- Interceptar borrado (deleteProperty)
- Iteraciones (ownKeys)
- Instanciaci√≥n (construct)

Ejemplo validaci√≥n:

```javascript
const usuario = {};

const proxyUser = new Proxy(usuario, {
  set(obj, prop, valor) {
    if (prop === "edad" && typeof valor !== "number") {
      throw new TypeError("Edad debe ser un n√∫mero");
    }
    return Reflect.set(obj, prop, valor);
  },
});

proxyUser.edad = 30; // OK
proxyUser.edad = "treinta"; // Error
```

## Virtual Objects

Podemos crear objetos que no existen f√≠sicamente pero se comportan como si existieran.

```javascript
const virtualArray = new Proxy(
  {},
  {
    get(obj, prop) {
      return `Valor virtual para √≠ndice ${prop}`;
    },
  }
);

console.log(virtualArray[10]); // Valor virtual para √≠ndice 10
```

## Transparent Wrappers

Se usan para agregar funcionalidades sin modificar el objeto original.

```javascript
function logAccess(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      console.log(`Accediendo a ${prop}`);
      return Reflect.get(target, prop);
    },
  });
}

const datos = logAccess({ x: 10, y: 20 });
console.log(datos.x); // Accediendo a x ‚Üí 10
```

## Revocable Proxies

Un Proxy puede ser revocable, lo que significa que puede dejar de funcionar en cualquier momento.

```javascript
const { proxy, revoke } = Proxy.revocable({ secreto: 42 }, {});

console.log(proxy.secreto); // 42
revoke();
console.log(proxy.secreto); // Error: Cannot perform 'get' on a proxy that has been revoked
```

## Casos de uso reales

‚úÖ Validaci√≥n de datos antes de asignarlos.

‚úÖ Registro de accesos para depuraci√≥n.

‚úÖ Simulaci√≥n de datos para pruebas.

‚úÖ Controles de seguridad en librer√≠as.

‚úÖ APIs din√°micas que se adaptan a contexto.

üìå Resumen de traps m√°s comunes

| Trap           | Uso                               |
| -------------- | --------------------------------- |
| get            | Intercepta lectura de propiedades |
| set            | Intercepta escritura              |
| deleteProperty | Intercepta borrado                |
| ownKeys        | Intercepta iteraciones de claves  |
| has            | Intercepta el operador in         |
| apply          | Intercepta llamadas de funci√≥n    |
| construct      | Intercepta new                    |
