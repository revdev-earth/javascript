# 28. Micro-frontends y Architecture

Los **Micro-frontends** son la extensión del concepto de **microservicios** al **frontend**: dividen una aplicación en **módulos independientes**, que pueden ser desarrollados, desplegados y actualizados de forma aislada, pero que se integran en la experiencia final como si fuera una sola aplicación.

## 1. Module Federation

- Introducido en **Webpack 5**.
- Permite a una aplicación cargar módulos **en tiempo de ejecución** desde otra aplicación.
- Ideal para compartir componentes, páginas o librerías entre diferentes equipos sin hacer un build conjunto.

**Ejemplo básico en `webpack.config.js`:**

```javascript
new ModuleFederationPlugin({
  name: "app1",
  filename: "remoteEntry.js",
  exposes: {
    "./Header": "./src/Header",
  },
  remotes: {
    app2: "app2@http://localhost:3002/remoteEntry.js",
  },
});
```

## 2. Micro-frontend Patterns

Los principales patrones para integrar micro-frontends incluyen:

| Patrón                                 | Descripción                                         | Ejemplo              |
| -------------------------------------- | --------------------------------------------------- | -------------------- |
| **Build-time integration**             | Se compilan juntos en el build final.               | Monorepos.           |
| **Run-time integration (client-side)** | Se cargan dinámicamente en el navegador.            | Module Federation.   |
| **Run-time integration (server-side)** | El servidor arma el HTML combinando los fragmentos. | SSR + Edge includes. |
| **Hybrid**                             | Combina server-side y client-side.                  | Next.js con MF.      |

## 3. Iframe Communication

- Patrón clásico y aislado para integrar micro-frontends.
- Ventaja: aislamiento total de CSS/JS y seguridad.
- Desventaja: peor rendimiento y experiencia de usuario.
- Comunicación con `postMessage`:

```javascript
iframe.contentWindow.postMessage(
  {
    action: "update",
    data: {},
  },
  "*"
);
```

## 4. Shared Dependencies

- Problema: si cada micro-frontend carga React, la app final será muy pesada.
- Solución: **Compartir dependencias comunes** usando Module Federation o monorepos.

**Ejemplo con Webpack:**

```javascript
shared: {
    react: {
        singleton: true,
        requiredVersion: "^18.0.0"
    },
    "react-dom": {
        singleton: true,
    },
}
```

## 5. Deployment Strategies

- **Independiente**: cada micro-frontend se despliega por separado y se actualiza sin afectar al resto.
- **Orquestado**: un "shell" principal decide qué versión de cada micro-frontend cargar.
- **CI/CD por equipo**: pipelines separadas para cada módulo.

## 6. Team Collaboration

- Cada equipo trabaja como si desarrollara un **producto independiente**.

### Ventajas:

- Autonomía total en releases.
- Stack tecnológico independiente (React, Vue, Svelte coexistiendo).

### Retos:

- Consistencia en el diseño.
- Coordinación de cambios en APIs internas.
- Estrategias para **versionado y rollback**.

## Beneficios

- Escalabilidad organizacional.
- Reducción de acoplamiento.
- Actualizaciones rápidas de partes específicas.

## Desventajas

- Complejidad en integración.
- Riesgo de duplicación de dependencias.
- Mayor esfuerzo en testing end-to-end.
