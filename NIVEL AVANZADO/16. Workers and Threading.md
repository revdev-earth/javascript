# 16. Workers and Threading

JavaScript tradicionalmente se ejecuta en **un solo hilo** (single-threaded) usando el **event loop**. Sin embargo, para tareas pesadas o paralelizaci√≥n, podemos usar **workers** para mover la carga fuera del hilo principal.

## 1. Web Workers

- Ejecutan c√≥digo JavaScript en **otro hilo**.
- No tienen acceso al DOM directamente.
- Comunicaci√≥n mediante **message passing** (`postMessage` y `onmessage`).

```javascript
// worker.js
self.onmessage = (e) => {
  const result = e.data * 2;
  self.postMessage(result);
};

// main.js
const worker = new Worker("worker.js");
worker.onmessage = (e) => console.log("Resultado:", e.data);
worker.postMessage(5);
```

üí° **Uso t√≠pico:** c√°lculos intensivos, procesamiento de im√°genes, an√°lisis de datos.

## 2. Service Workers

- Trabajan como un **proxy** entre la app y la red.
- Funcionan incluso **offline** gracias al **Cache API**.
- Soportan **push notifications** y **background sync**.
- Son clave para crear **PWA** (Progressive Web Apps).

```javascript
// service-worker.js
self.addEventListener("install", (e) => {
  e.waitUntil(
    caches
      .open("v1")
      .then((cache) => cache.addAll(["/index.html", "/style.css"]))
  );
});
```

üí° **Uso t√≠pico:** cacheo de recursos, mejoras de rendimiento, modo offline.

## 3. Shared Workers

- Compartidos por m√∫ltiples pesta√±as o iframes que provengan del mismo origen.
- Ideales para compartir estado o conexi√≥n a un mismo recurso (ej. WebSocket).

```javascript
// shared-worker.js
self.onconnect = (e) => {
  const port = e.ports[0];
  port.onmessage = (msg) => port.postMessage(`Recibido: ${msg.data}`);
};
```

üí° **Uso t√≠pico:** chat multi-pesta√±a, sincronizaci√≥n de datos entre ventanas.

## 4. Worker Threads (Node.js)

- Implementaci√≥n en Node.js para tareas CPU-bound sin bloquear el event loop.
- Similar a Web Workers pero con acceso completo a m√≥dulos de Node.

```javascript
// worker.js
const { parentPort } = require("worker_threads");

parentPort.on("message", (num) => {
  parentPort.postMessage(num * 2);
});
```

üí° **Uso t√≠pico:** procesamiento intensivo en servidores Node.js.

## 5. Message Passing

- Workers no comparten memoria (en la mayor√≠a de casos), se comunican enviando mensajes **copiados** (structured cloning).

### Ejemplo b√°sico:

```javascript
worker.postMessage({ action: "start" });
worker.onmessage = (e) => console.log(e.data);
```

## 6. Transferable Objects

- Permiten **mover** (no copiar) grandes bloques de datos como `ArrayBuffer` entre hilos.
- Evita duplicaci√≥n en memoria, mejorando rendimiento.

```javascript
const buffer = new ArrayBuffer(1024);
worker.postMessage(buffer, [buffer]); // Se transfiere, no se copia
```

üí° **Uso t√≠pico:** procesamiento de video/audio, datos binarios grandes.

## 7. Performance Considerations

- Crear muchos workers puede ser contraproducente: cada uno consume memoria y recursos.
- Idealmente, n√∫mero de workers ‚âà n√∫mero de n√∫cleos de CPU.
- Mantener workers **vivos** si son reutilizados, en lugar de crearlos/desecharlos constantemente.

### üìå Resumen comparativo:

| Tipo             | Contexto  | Comunicaci√≥n  | Uso principal                    |
| ---------------- | --------- | ------------- | -------------------------------- |
| Web Worker       | Navegador | Mensajes      | Procesos pesados sin bloquear UI |
| Service Worker   | Navegador | Eventos       | Cache, offline, PWA              |
| Shared Worker    | Navegador | Mensajes      | Compartir estado entre pesta√±as  |
| Worker Thread    | Node.js   | Mensajes      | Procesamiento CPU-bound          |
| Transferable Obj | Ambos     | Transferencia | Datos binarios grandes           |
