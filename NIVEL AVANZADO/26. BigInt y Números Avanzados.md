# 26. BigInt y N√∫meros Avanzados

JavaScript usa por defecto el tipo `Number`, basado en el est√°ndar **IEEE 754 de 64 bits en coma flotante**. Esto implica:

- Rango seguro entero: **¬±(2^53 - 1)**
- Precisi√≥n limitada para decimales muy largos.
- Posibles errores de redondeo en operaciones.

Cuando necesitas trabajar con enteros enormes o exactos ‚Üí entra en juego **BigInt**.

## 1. BigInt Operations

- Se crea agregando una `n` al final del n√∫mero o usando el constructor `BigInt()`.
- Soporta operaciones aritm√©ticas b√°sicas: `+`, `-`, `*`, `/`, `%`, `**`.

**Ejemplo:**

```javascript
const big1 = 123456789012345678901234567890n;
const big2 = BigInt("987654321098765432109876543210");
console.log(big1 + big2);
```

‚ö†Ô∏è **Regla:** No se mezclan `BigInt` y `Number` directamente.

```javascript
// ‚ùå Error:
1n + 1; // TypeError

// ‚úÖ Correcto:
1n + BigInt(1);
```

## 2. Precision Handling

- `Number` pierde precisi√≥n para valores > **2^53**.
- `BigInt` mantiene precisi√≥n exacta en enteros sin l√≠mite pr√°ctico (solo limitado por memoria).

**Ejemplo problema con `Number`:**

```javascript
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992 ‚ùå (pierde precisi√≥n)
```

**Con `BigInt`:**

```javascript
console.log(9007199254740991n + 2n); // 9007199254740993n ‚úÖ
```

## 3. Mathematical Computations

- `Math` API no funciona directamente con `BigInt`.
- Para operaciones avanzadas (ra√≠z cuadrada, trigonometr√≠a) ‚Üí convertir a `Number` o usar librer√≠as como **big-integer** o **decimal.js**.

**Ejemplo:**

```javascript
const big = 144n;
const sqrt = Math.sqrt(Number(big)); // 12
```

## 4. Number Limits

```javascript
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991
console.log(Number.MAX_VALUE); // 1.7976931348623157e+308
console.log(Number.MIN_VALUE); // 5e-324
```

- BigInt no tiene estos l√≠mites, pero no soporta decimales.

## 5. Scientific Notation

- `Number` soporta notaci√≥n cient√≠fica:

```javascript
console.log(1.23e5); // 123000
console.log(5e-3); // 0.005
```

- BigInt **no soporta** notaci√≥n cient√≠fica:

```javascript
// ‚ùå SyntaxError
// const big = 1e10n;
```

## 6. Performance Implications

- BigInt es m√°s lento que Number en operaciones peque√±as.
- √ösalo solo cuando necesites **precisi√≥n absoluta** y n√∫meros muy grandes.
- En c√°lculos financieros, criptograf√≠a o blockchain es com√∫n.

## üìå Resumen de elecci√≥n:

| Necesidad                         | Tipo                        |
| --------------------------------- | --------------------------- |
| C√°lculo r√°pido con valores < 2^53 | `Number`                    |
| Enteros exactos muy grandes       | `BigInt`                    |
| Decimales de alta precisi√≥n       | Librer√≠as como `decimal.js` |
