# 10. Functional Programming Complete

La programación funcional (FP) es un paradigma en el que el software se construye usando funciones puras, datos inmutables y composición de funciones, en lugar de cambiar estado y usar efectos secundarios.

## Pure Functions

Una función pura:

- Devuelve el mismo resultado para las mismas entradas.
- No produce efectos secundarios.

```javascript
// Función pura
function suma(a, b) {
  return a + b;
}

// Función impura (usa variable externa)
let contador = 0;
function incrementar() {
  contador++; // Efecto secundario
}
```

## Immutability

En FP los datos son inmutables: no se modifican, se crean nuevos.

```javascript
const usuario = { nombre: "Ana", edad: 25 };

// ❌ Mutación
usuario.edad = 26;

// ✅ Inmutabilidad
const usuarioNuevo = { ...usuario, edad: 26 };
```

Beneficio → Menos errores y fácil razonamiento.

## Higher-Order Functions

Funciones que reciben otras funciones o devuelven funciones.

```javascript
function operar(fn, x, y) {
  return fn(x, y);
}

console.log(operar((a, b) => a + b, 2, 3)); // 5
console.log(operar((a, b) => a * b, 2, 3)); // 6
```

## Composition

Unir funciones pequeñas para crear funciones más complejas.

```javascript
const sumar = (x) => x + 2;
const multiplicar = (x) => x * 3;

// Composición manual
const combinado = (x) => multiplicar(sumar(x));
console.log(combinado(5)); // (5+2)*3 = 21

// Composición genérica
const compose = (f, g) => (x) => f(g(x));
const combinado2 = compose(multiplicar, sumar);
console.log(combinado2(5)); // 21
```

## Currying

Transformar una función de varios parámetros en una secuencia de funciones de un solo parámetro.

```javascript
function curriedSum(a) {
  return function (b) {
    return a + b;
  };
}

console.log(curriedSum(2)(3)); // 5
```

Ventaja → Permite crear funciones preconfiguradas.

## Partial Application

Parecido al currying, pero predefiniendo algunos argumentos.

```javascript
function multiplicar(a, b) {
  return a * b;
}

const duplicar = multiplicar.bind(null, 2);
console.log(duplicar(5)); // 10
```

## Functors

Un functor es un objeto con un método map que aplica una función a su valor.

Ejemplo con arrays:

```javascript
const nums = [1, 2, 3];
const dobles = nums.map((x) => x * 2);
console.log(dobles); // [2, 4, 6]
```

## Monads

Una mónada es un functor con flatMap o chain que encapsula un contexto (null, promesa, etc.) y permite componer operaciones sin romper la cadena.

Ejemplo básico (Maybe Monad):

```javascript
const Maybe = (value) => ({
  map: (fn) => (value ? Maybe(fn(value)) : Maybe(null)),
  get: () => value,
});

const resultado = Maybe(5)
  .map((x) => x + 2)
  .map((x) => x * 3)
  .get();

console.log(resultado); // 21
```

## Beneficios de FP

✅ Código predecible y fácil de probar.
✅ Mayor reutilización.
✅ Menos errores por mutaciones de estado.
✅ Escalabilidad en proyectos grandes.

📌 Resumen visual

| Concepto               | Descripción                                            |
| ---------------------- | ------------------------------------------------------ |
| Pure Functions         | Sin efectos secundarios, mismo output para mismo input |
| Immutability           | Datos que no cambian                                   |
| Higher-Order Functions | Reciben/devuelven funciones                            |
| Composition            | Combinar funciones pequeñas                            |
| Currying               | Separar parámetros en funciones                        |
| Partial Application    | Preconfigurar algunos parámetros                       |
| Functors               | Objeto con map                                         |
| Monads                 | Functor con flatMap                                    |
