# 10. Functional Programming Complete

La programaciÃ³n funcional (FP) es un paradigma en el que el software se construye usando funciones puras, datos inmutables y composiciÃ³n de funciones, en lugar de cambiar estado y usar efectos secundarios.

## Pure Functions

Una funciÃ³n pura:

- Devuelve el mismo resultado para las mismas entradas.
- No produce efectos secundarios.

```javascript
// FunciÃ³n pura
function suma(a, b) {
  return a + b;
}

// FunciÃ³n impura (usa variable externa)
let contador = 0;
function incrementar() {
  contador++; // Efecto secundario
}
```

## Immutability

En FP los datos son inmutables: no se modifican, se crean nuevos.

```javascript
const usuario = { nombre: "Ana", edad: 25 };

// âŒ MutaciÃ³n
usuario.edad = 26;

// âœ… Inmutabilidad
const usuarioNuevo = { ...usuario, edad: 26 };
```

Beneficio â†’ Menos errores y fÃ¡cil razonamiento.

## Higher-Order Functions

Funciones que reciben otras funciones o devuelven funciones.

```javascript
function operar(fn, x, y) {
  return fn(x, y);
}

console.log(operar((a, b) => a + b, 2, 3)); // 5
console.log(operar((a, b) => a * b, 2, 3)); // 6
```

## Composition

Unir funciones pequeÃ±as para crear funciones mÃ¡s complejas.

```javascript
const sumar = (x) => x + 2;
const multiplicar = (x) => x * 3;

// ComposiciÃ³n manual
const combinado = (x) => multiplicar(sumar(x));
console.log(combinado(5)); // (5+2)*3 = 21

// ComposiciÃ³n genÃ©rica
const compose = (f, g) => (x) => f(g(x));
const combinado2 = compose(multiplicar, sumar);
console.log(combinado2(5)); // 21
```

## Currying

Transformar una funciÃ³n de varios parÃ¡metros en una secuencia de funciones de un solo parÃ¡metro.

```javascript
function curriedSum(a) {
  return function (b) {
    return a + b;
  };
}

console.log(curriedSum(2)(3)); // 5
```

Ventaja â†’ Permite crear funciones preconfiguradas.

## Partial Application

Parecido al currying, pero predefiniendo algunos argumentos.

```javascript
function multiplicar(a, b) {
  return a * b;
}

const duplicar = multiplicar.bind(null, 2);
console.log(duplicar(5)); // 10
```

## Functors

Un functor es un objeto con un mÃ©todo map que aplica una funciÃ³n a su valor.

Ejemplo con arrays:

```javascript
const nums = [1, 2, 3];
const dobles = nums.map((x) => x * 2);
console.log(dobles); // [2, 4, 6]
```

## Monads

Una mÃ³nada es un functor con flatMap o chain que encapsula un contexto (null, promesa, etc.) y permite componer operaciones sin romper la cadena.

Ejemplo bÃ¡sico (Maybe Monad):

```javascript
const Maybe = (value) => ({
  map: (fn) => (value ? Maybe(fn(value)) : Maybe(null)),
  get: () => value,
});

const resultado = Maybe(5)
  .map((x) => x + 2)
  .map((x) => x * 3)
  .get();

console.log(resultado); // 21
```

## Beneficios de FP

âœ… CÃ³digo predecible y fÃ¡cil de probar.
âœ… Mayor reutilizaciÃ³n.
âœ… Menos errores por mutaciones de estado.
âœ… Escalabilidad en proyectos grandes.

ðŸ“Œ Resumen visual

| Concepto               | DescripciÃ³n                                            |
| ---------------------- | ------------------------------------------------------ |
| Pure Functions         | Sin efectos secundarios, mismo output para mismo input |
| Immutability           | Datos que no cambian                                   |
| Higher-Order Functions | Reciben/devuelven funciones                            |
| Composition            | Combinar funciones pequeÃ±as                            |
| Currying               | Separar parÃ¡metros en funciones                        |
| Partial Application    | Preconfigurar algunos parÃ¡metros                       |
| Functors               | Objeto con map                                         |
| Monads                 | Functor con flatMap                                    |
