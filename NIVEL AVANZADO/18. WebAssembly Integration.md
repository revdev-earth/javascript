# 18. WebAssembly Integration

**WebAssembly (WASM)** es un formato binario portable que se ejecuta en el navegador (y en Node.js) con **rendimiento casi nativo**, permitiendo integrar c√≥digo escrito en C, C++, Rust, Go, y otros lenguajes.

üí° Piensa en WASM como un "m√≥dulo binario" que el navegador carga y ejecuta casi tan r√°pido como si fuera c√≥digo nativo, pero seguro y aislado.

## 1. WASM Compilation

El proceso general:

1. Escribir c√≥digo en C/C++/Rust.
2. Compilarlo a `.wasm` con herramientas como **Emscripten** o **wasm-pack**.
3. Cargarlo en JS.

### Ejemplo en C:

```c
// archivo: suma.c
int add(int a, int b) {
    return a + b;
}
```

### Compilaci√≥n (con Emscripten):

```bash
emcc suma.c -s WASM=1 -o suma.wasm
```

## 2. JS Interop

Para usar `.wasm` desde JS:

```javascript
const wasmModule = await WebAssembly.instantiateStreaming(fetch("suma.wasm"));
console.log(wasmModule.instance.exports.add(5, 7)); // 12
```

- **`exports`** ‚Üí funciones y variables disponibles para JS.
- **`imports`** ‚Üí funciones que WASM puede llamar de JS.

## 3. Memory Management

- WASM usa su propio **heap lineal** (`WebAssembly.Memory`).
- Puedes compartirlo con JS para intercambiar datos binarios.

```javascript
const memory = new WebAssembly.Memory({ initial: 1 }); // 64KB
const view = new Uint8Array(memory.buffer);
view[0] = 42;
```

üí° **Ideal para:** pasar buffers grandes (im√°genes, audio) sin copias costosas.

## 4. Performance Benefits

### Ventajas principales:

- Ejecuci√≥n **m√°s r√°pida** que JS en c√°lculos pesados.
- **Tipado est√°tico**: optimizaci√≥n a nivel de CPU.
- Menor **uso de CPU** para algoritmos complejos.

### Limitaciones:

- No reemplaza todo el JS, es m√°s para **m√≥dulos espec√≠ficos**.
- Llamadas frecuentes JS‚ÜîWASM pueden ser un cuello de botella.

## 5. Toolchain

- **Emscripten** ‚Üí Para C/C++.
- **wasm-pack** / **wasm-bindgen** ‚Üí Para Rust.
- **AssemblyScript** ‚Üí Para escribir WASM en TypeScript.
- **Binaryen** ‚Üí Optimizaci√≥n y manipulaci√≥n de WASM.

### Ejemplo Rust:

```bash
cargo install wasm-pack
wasm-pack build --target web
```

## 6. Debugging

- Navegadores modernos muestran **c√≥digo fuente original** (source maps).
- Puedes depurar en **DevTools** como si fuera JS, pero con vistas binarias.

### Herramientas √∫tiles:

- `wasm2wat` (decompilador binario ‚Üí texto legible)
- `wat2wasm` (inverso)

## 7. Use Cases

- **Procesamiento de im√°genes/video** (filtros, compresi√≥n).
- **Criptograf√≠a** (hashing, cifrado).
- **Juegos 3D** (port de motores como Unity o Unreal).
- **Simulaciones cient√≠ficas** (f√≠sica, fluidos).
- **Machine Learning** (modelos optimizados).
- **Conversi√≥n de formatos** (PDF, audio).

### üìå Flujo general de integraci√≥n WASM:

```
C/C++/Rust/AssemblyScript
          ‚Üì
    (compilaci√≥n)
      archivo.wasm
          ‚Üì
    (fetch / load)
JS <‚îÄ‚îÄ intercambio de datos ‚îÄ‚îÄ> WASM
```

### üí° Ejemplo completo:

```javascript
async function loadWasm() {
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch("suma.wasm")
  );
  console.log("Resultado:", instance.exports.add(10, 15));
}

loadWasm();
```
